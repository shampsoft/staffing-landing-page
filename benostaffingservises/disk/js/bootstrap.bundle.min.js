P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Z.dataApiClickHandler),
        P.on(window, "load.bs.carousel.data-api", () => {
            const e = t.find('[data-bs-ride="carousel"]');
            for (let t = 0, i = e.length; t < i; t++) Z.carouselInterface(e[t], Z.getInstance(e[t]));
        }),
        _(Z);
    const J = { toggle: !0, parent: "" },
        tt = { toggle: "boolean", parent: "(string|element)" };
    class et extends B {
        constructor(e, i) {
            super(e),
                (this._isTransitioning = !1),
                (this._config = this._getConfig(i)),
                (this._triggerArray = t.find(`[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`));
            const s = t.find('[data-bs-toggle="collapse"]');
            for (let e = 0, i = s.length; e < i; e++) {
                const i = s[e],
                    o = n(i),
                    r = t.find(o).filter((t) => t === this._element);
                null !== o && r.length && ((this._selector = o), this._triggerArray.push(i));
            }
            (this._parent = this._config.parent ? this._getParent() : null), this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
        }
        static get Default() {
            return J;
        }
        static get NAME() {
            return "collapse";
        }
        toggle() {
            this._element.classList.contains("show") ? this.hide() : this.show();
        }
        show() {
            if (this._isTransitioning || this._element.classList.contains("show")) return;
            let e, i;
            this._parent &&
                ((e = t.find(".show, .collapsing", this._parent).filter((t) => ("string" == typeof this._config.parent ? t.getAttribute("data-bs-parent") === this._config.parent : t.classList.contains("collapse")))),
                0 === e.length && (e = null));
            const n = t.findOne(this._selector);
            if (e) {
                const t = e.find((t) => n !== t);
                if (((i = t ? et.getInstance(t) : null), i && i._isTransitioning)) return;
            }
            if (P.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
            e &&
                e.forEach((t) => {
                    n !== t && et.collapseInterface(t, "hide"), i || R.set(t, "bs.collapse", null);
                });
            const s = this._getDimension();
            this._element.classList.remove("collapse"),
                this._element.classList.add("collapsing"),
                (this._element.style[s] = 0),
                this._triggerArray.length &&
                    this._triggerArray.forEach((t) => {
                        t.classList.remove("collapsed"), t.setAttribute("aria-expanded", !0);
                    }),
                this.setTransitioning(!0);
            const o = "scroll" + (s[0].toUpperCase() + s.slice(1));
            this._queueCallback(
                () => {
                    this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), (this._element.style[s] = ""), this.setTransitioning(!1), P.trigger(this._element, "shown.bs.collapse");
                },
                this._element,
                !0
            ),
                (this._element.style[s] = this._element[o] + "px");
        }
        hide() {
            if (this._isTransitioning || !this._element.classList.contains("show")) return;
            if (P.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
            const t = this._getDimension();
            (this._element.style[t] = this._element.getBoundingClientRect()[t] + "px"), f(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
            const e = this._triggerArray.length;
            if (e > 0)
                for (let t = 0; t < e; t++) {
                    const e = this._triggerArray[t],
                        i = s(e);
                    i && !i.classList.contains("show") && (e.classList.add("collapsed"), e.setAttribute("aria-expanded", !1));
                }
            this.setTransitioning(!0),
                (this._element.style[t] = ""),
                this._queueCallback(
                    () => {
                        this.setTransitioning(!1), this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), P.trigger(this._element, "hidden.bs.collapse");
                    },
                    this._element,
                    !0
                );
        }
        // setTransitioning(t) {
        //     this._isTransitioning = t;
        // }
        // _getConfig(t) {
        //     return ((t = { ...J, ...t }).toggle = Boolean(t.toggle)), l("collapse", t, tt), t;
        // }
        // _getDimension() {
        //     return this._element.classList.contains("width") ? "width" : "height";
        // }
        // _getParent() {
        //     let { parent: e } = this._config;
        //     e = a(e);
        //     const i = `[data-bs-toggle="collapse"][data-bs-parent="${e}"]`;
        //     return (
        //         t.find(i, e).forEach((t) => {
        //             const e = s(t);
        //             this._addAriaAndCollapsedClass(e, [t]);
        //         }),
        //         e
        //     );
        // }
        // _addAriaAndCollapsedClass(t, e) {
        //     if (!t || !e.length) return;
        //     const i = t.classList.contains("show");
        //     e.forEach((t) => {
        //         i ? t.classList.remove("collapsed") : t.classList.add("collapsed"), t.setAttribute("aria-expanded", i);
        //     });
        // }
        // static collapseInterface(t, e) {
        //     let i = et.getInstance(t);
        //     const n = { ...J, ...U.getDataAttributes(t), ...("object" == typeof e && e ? e : {}) };
        //     if ((!i && n.toggle && "string" == typeof e && /show|hide/.test(e) && (n.toggle = !1), i || (i = new et(t, n)), "string" == typeof e)) {
        //         if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`);
        //         i[e]();
        //     }
        // }
        // static jQueryInterface(t) {
        //     return this.each(function () {
        //         et.collapseInterface(this, t);
        //     });
        // }
    }